name,assertion_sv,line_number,expected_result,code
assertion_1,assert property (@(posedge clock) freg == from),12,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from; //
    input [2:0] to;
    reg [2:0] b[0:7];
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions;
    initial begin
        treg = 0;
        freg = 0; //
    end
    always @ (posedge clock) begin 
        freg = from; //
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_2,assert property (@(posedge clock) treg == to),13,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to; //
    reg [2:0] b[0:7];
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions;
    initial begin
        treg = 0; //
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from; 
        treg = to; //
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_3,assert property (@(posedge clock) valid |-> b[treg] == b[freg]),19,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg]; //
            b[freg] = 0; 
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_4,assert property (@(posedge clock) valid |-> b[freg] == 3'b000),20,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0; //
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0; //
        end 
    end
    assign valid = (b[treg] == 3'b000) && 
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_5,assert property (@(posedge clock) b[treg] != 3'b000),19,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions;
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0; // 
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_6,assert property (@(posedge clock) !valid |-> b[treg] != b[freg]),19,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0; // 
        freg = 0; //
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin //
            b[treg] = b[freg]; //
            b[freg] = 0; // 
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_7,assert property (valid == (b[treg] == 3'b000)),24,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) && 
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            ); //
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_8,assert property (!(parity ^ oddInversions)),48,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7];
    reg [2:0] freg, treg;
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7]; 
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_9,assert property (parity != oddInversions),48,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7];
    reg [2:0] freg, treg;
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5)); //
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7]; 
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0); //
endmodule"
assertion_10,assert property (permutation != oddInversions),48,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7];
    reg [2:0] freg, treg;
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7]; // 
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0); //
endmodule"
assertion_11,assert property (parity == oddInversions),48,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7];
    reg [2:0] freg, treg;
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5)); //
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];  
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0); //
endmodule"
assertion_12,assert property (@(posedge clock) freg != from),12,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from; //
    input [2:0] to;
    reg [2:0] b[0:7];
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions;
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin 
        freg = from; //
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_13,assert property (@(posedge clock) treg != to),13,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to; //
    reg [2:0] b[0:7];
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions;
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from; 
        treg = to; //
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_14,assert property (@(posedge clock) valid |-> b[treg] != b[freg]),19,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg]; //
            b[freg] = 0; 
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            ); //
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_15,assert property (@(posedge clock) valid |-> b[freg] != 3'b000),20,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0; //
    end
    always @ (posedge clock) begin
        freg = from; //
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg]; //
            b[freg] = 0; //
        end 
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_16,assert property (@(posedge clock) b[treg] == 3'b000),19,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions;
    initial begin
        treg = 0; //
        freg = 0; //
    end
    always @ (posedge clock) begin
        freg = from; //
        treg = to; //
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0; // 
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_17,assert property (@(posedge clock) !valid |-> b[treg] == b[freg]),19,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0; //
        freg = 0; //
    end
    always @ (posedge clock) begin
        freg = from; //
        treg = to; //
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg]; //
            b[freg] = 0; 
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_18,assert property (valid != (b[treg] == 3'b000)),24,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0; //
        freg = 0; //
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0; //
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) && 
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_19,assert property ((parity ^ oddInversions)),48,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7];
    reg [2:0] freg, treg;
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5)); //
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0); //
endmodule"
assertion_20,assert property (parity == oddInversions),48,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7];
    reg [2:0] freg, treg;
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5)); //
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7]; // 
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0); //
endmodule"
assertion_21,assert property (permutation == oddInversions),48,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7];
    reg [2:0] freg, treg;
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7]; // 
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0); //
endmodule"
assertion_22,assert property (parity != oddInversions),48,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7];
    reg [2:0] freg, treg;
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5)); //
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];  
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0); //
endmodule"
assertion_23,assert property (@(posedge clock) freg == from),12,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from; //
    input [2:0] to;
    reg [2:0] b[0:7];
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions;
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin 
        freg = from; //
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_24,assert property (@(posedge clock) treg == to),13,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to; //
    reg [2:0] b[0:7];
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions;
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from; 
        treg = to; //
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_25,assert property (@(posedge clock) valid |-> b[treg] == b[freg]),19,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions;
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg]; //
            b[freg] = 0; // 
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_26,assert property (@(posedge clock) valid |-> b[freg] == 3'b000),20,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions;
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0; //
        end  
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_27,assert property (@(posedge clock) b[treg] != 3'b000),19,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions;
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg]; //
            b[freg] = 0; // 
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_28,assert property (@(posedge clock) !valid |-> b[treg] != b[freg]),19,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg]; //
            b[freg] = 0; // 
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            ); //
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_29,assert property (valid == (b[treg] == 3'b000)),24,PASS,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7]; //
    reg [2:0] freg, treg; //
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg]; //
            b[freg] = 0; //
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) && // 
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5));
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7];
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0);
endmodule"
assertion_30,assert property (!(parity ^ oddInversions)),48,FAIL,"module main(clock,from,to);
    input clock;
    input [2:0] from;
    input [2:0] to;
    reg [2:0] b[0:7];
    reg [2:0] freg, treg;
    wire valid, parity, permutation, oddInversions; //
    initial begin
        treg = 0;
        freg = 0;
    end
    always @ (posedge clock) begin
        freg = from;
        treg = to;
    end
    always @ (posedge clock) begin
        if (valid) begin
            b[treg] = b[freg];
            b[freg] = 0;
        end
    end
    assign valid = (b[treg] == 3'b000) &&
           (((treg[1:0] == freg[1:0]) && !(treg[2] == freg[2])) ||
            ((treg[2] == freg[2]) &&
             (((treg[1:0]==2'b00) && (freg[1:0]==2'b01)) ||
              ((treg[1:0]==2'b01) && (freg[0]==0)) ||
              ((treg[1:0]==2'b10) && (freg[0]==1)) ||
              ((treg[1:0]==2'b11) && (freg[1:0]==2'b10))
              )
             )
            );
    assign parity = 
       (((b[0] & 5) == 1) | ((b[0] & 5) == 4)) ^
       (((b[1] & 5) == 0) | ((b[1] & 5) == 5)) ^
       (((b[2] & 5) == 1) | ((b[2] & 5) == 4)) ^
       (((b[3] & 5) == 0) | ((b[3] & 5) == 5)) ^
       (((b[4] & 5) == 1) | ((b[4] & 5) == 4)) ^
       (((b[5] & 5) == 0) | ((b[5] & 5) == 5)) ^
       (((b[6] & 5) == 1) | ((b[6] & 5) == 4)) ^
       (((b[7] & 5) == 0) | ((b[7] & 5) == 5)); //
    assign permutation = b[0]!=b[1] && b[0]!=b[2] && b[0]!=b[3] &&
           b[0]!=b[4] && b[0]!=b[5] && b[0]!=b[6] && b[0]!=b[7] &&
           b[1]!=b[2] && b[1]!=b[3] && b[1]!=b[4] && b[1]!=b[5] &&
           b[1]!=b[6] && b[1]!=b[7] && b[2]!=b[3] && b[2]!=b[4] &&
           b[2]!=b[5] && b[2]!=b[6] && b[2]!=b[7] && b[3]!=b[4] &&
           b[3]!=b[5] && b[3]!=b[6] && b[3]!=b[7] && b[4]!=b[5] &&
           b[4]!=b[6] && b[4]!=b[7] && b[5]!=b[6] && b[5]!=b[7] &&
           b[6]!=b[7]; 
    assign oddInversions = (b[4]==0 || b[5]==0 || b[6]==0 || b[7]==0) ^
           (b[0]>b[1] && b[1]!=0) ^ (b[0]>b[2] && b[2]!=0) ^
           (b[0]>b[3] && b[3]!=0) ^ (b[0]>b[4] && b[4]!=0) ^
           (b[0]>b[5] && b[5]!=0) ^ (b[0]>b[6] && b[6]!=0) ^
           (b[0]>b[7] && b[7]!=0) ^ (b[1]>b[2] && b[2]!=0) ^
           (b[1]>b[3] && b[3]!=0) ^ (b[1]>b[4] && b[4]!=0) ^
           (b[1]>b[5] && b[5]!=0) ^ (b[1]>b[6] && b[6]!=0) ^
           (b[1]>b[7] && b[7]!=0) ^ (b[2]>b[3] && b[3]!=0) ^
           (b[2]>b[4] && b[4]!=0) ^ (b[2]>b[5] && b[5]!=0) ^
           (b[2]>b[6] && b[6]!=0) ^ (b[2]>b[7] && b[7]!=0) ^
           (b[3]>b[4] && b[4]!=0) ^ (b[3]>b[5] && b[5]!=0) ^
           (b[3]>b[6] && b[6]!=0) ^ (b[3]>b[7] && b[7]!=0) ^
           (b[4]>b[5] && b[5]!=0) ^ (b[4]>b[6] && b[6]!=0) ^
           (b[4]>b[7] && b[7]!=0) ^ (b[5]>b[6] && b[6]!=0) ^
           (b[5]>b[7] && b[7]!=0) ^ (b[6]>b[7] && b[7]!=0); //
endmodule"
